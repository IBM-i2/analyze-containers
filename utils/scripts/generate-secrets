#!/usr/bin/env bash
# i2, i2 Group, the i2 Group logo, and i2group.com are trademarks of N.Harris Computer Corporation.
# Â© N.Harris Computer Corporation (2022-2023)
#
# SPDX short identifier: MIT

set -e

USAGE="""
Usage:
  generate-secrets -t generate [-c {all|core|connectors[-i <connector1_name>] [-e <connector1_name>]}] [-v]
  generate-secrets -t clean [-v]
  generate-secrets -h

Options:
  -t <generate>         Generate certificates. 
  -t <clean>            Clean all certificates.
  -c <all>              Generate certificates for all components.
  -c <core>             Generate certificates for core components.
  -c <connectors>       Generate certificates for connectors only.
  -i <connector_name>   Names of the connectors to generate secrets for. To specify multiple connectors, add additional -i options.
  -e <connector_name>   Names of the connectors to not generate secrets for. To specify multiple connectors, add additional -e options.
  -v                    Verbose output.
  -h                    Display the help.
"""

source "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/common_functions.sh"
OPTIONS_FOR="generateSecrets"
parse_arguments "$@"

###############################################################################
# Defaults                                                                    #
###############################################################################

if [[ -z "${ENVIRONMENT}" ]]; then
  ENVIRONMENT="config-dev"
fi

if [[ -z "${TASK}" ]]; then
  TASK="generate"
fi

if [[ -z "${COMPONENTS}" ]]; then
  COMPONENTS="all"
fi

[[ "${TASK}" == "clean" ]] || [[ "${TASK}" == "generate" ]] || print_usage 1
[[ "${COMPONENTS}" == "all" || "${COMPONENTS}" == "connectors" || "${COMPONENTS}" == "core" ]] || print_usage 1

if [[ "${INCLUDED_CONNECTORS[*]}" && "${EXCLUDED_CONNECTORS[*]}" ]]; then
  print_error "Incompatible options: Both (-i) and (-e) were specified."
  print_usage 1
fi

DEV_ENV_SECRETS_DIR="${ANALYZE_CONTAINERS_ROOT_DIR}/dev-environment-secrets"
JAVA_CONTAINER_VOLUME_DIR="/simulatedKeyStore"

###############################################################################
# Loading common functions and variables                                      #
###############################################################################

# Load common functions
source "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/client_functions.sh"

# Load common variables
source "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/simulated_external_variables.sh"
source "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/common_variables.sh"
source "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/internal_helper_variables.sh"

check_environment_is_valid

###############################################################################
# Functions                                                                   #
###############################################################################
function run_java() {
  docker run \
    --rm \
    -e USER_ID="$(id -u)" -e GROUP_ID="$(id -g)" \
    -v "${GENERATED_SECRETS_DIR}/certificates:${JAVA_CONTAINER_VOLUME_DIR}" \
    "${I2A_TOOLS_IMAGE_NAME}:${I2A_DEPENDENCIES_IMAGES_TAG}" "$@"
}

function check_secret_does_not_exist() {
  local secret_name="${1}"
  local file_path="${2}"

  if [[ -d "${file_path}" ]]; then
    echo "Secrets for ${secret_name} already exist."
    echo "If you would like to regenerate the secrets, delete the ${file_path} folder."
    return 1
  fi

  return 0
}

function create_ca() {
  local CONTEXT="$1"
  local CA_CER="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}/CA.cer"
  local CA_KEY="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}/CA.key"
  local TMP="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}/CA.csr"
  local EXT="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}/x509.ext"

  print "Creating Certificate Authority"

  if [[ -f "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template" ]] && ! cmp --silent "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/templates/x509.ext.template" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template"; then
    # x509 file is different than expected, copy the new template
    cp -p "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/templates/x509.ext.template" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template"
    cp "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext"
  fi
  check_secret_does_not_exist "${CONTEXT}" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}" || return 0

  # Invalidate all other certificates
  if [[ "${CONTEXT}" == *"external"* ]]; then
    # Any certificate generated for external
    delete_folder_if_exists "${GENERATED_SECRETS_DIR}/certificates/${I2_ANALYZE_CERT_FOLDER_NAME}"
  else
    find "${GENERATED_SECRETS_DIR}/certificates" -maxdepth 1 -type d | while read -r file_location; do
      delete_folder_if_exists "${file_location}"
    done
  fi

  delete_folder_if_exists_and_create "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}"
  cp -p "${ANALYZE_CONTAINERS_ROOT_DIR}/utils/templates/x509.ext.template" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template"
  cp "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext.template" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext"

  # Generate CA.key
  run_java openssl req -new -nodes -newkey rsa:"${CA_KEY_SIZE}" -keyout "${CA_KEY}" -subj "/CN=i2Analyze-eia" -out "${TMP}"
  # Generate CA.cer
  run_java openssl x509 -req -sha256 -extfile "${EXT}" -extensions ca -in "${TMP}" -signkey "${CA_KEY}" -days "${CA_DURATION}" -out "${CA_CER}"

  # Clean up
  sudo chown -R "$(id -u):$(id -g)" "${GENERATED_SECRETS_DIR}"
  sudo chmod a+r "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/CA.cer"
  sudo rm "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/CA.csr" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/x509.ext"
}

function create_certificates() {
  local HOST_NAME="$1"
  local FQDN="$2"
  local TYPE="$3"
  local CONTEXT="$4"

  local KEY="${JAVA_CONTAINER_VOLUME_DIR}/${HOST_NAME}/server.key"
  local CER="${JAVA_CONTAINER_VOLUME_DIR}/${HOST_NAME}/server.cer"
  local TMP="${JAVA_CONTAINER_VOLUME_DIR}/${HOST_NAME}-key.csr"
  local CA_CER="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}CA/CA.cer"
  local CA_KEY="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}CA/CA.key"
  local CA_SRL="${JAVA_CONTAINER_VOLUME_DIR}/CA.srl"
  local EXT="${JAVA_CONTAINER_VOLUME_DIR}/${CONTEXT}CA/x509.ext"

  print "Create Raw Certificates"

  check_secret_does_not_exist "${HOST_NAME}" "${GENERATED_SECRETS_DIR}/certificates/${HOST_NAME}" || return 0
  delete_folder_if_exists_and_create "${GENERATED_SECRETS_DIR}/certificates/${HOST_NAME}"

  if [[ "${CONTEXT}" == external ]]; then
    sed "s/HOST_NAME/${FQDN}/" "${LOCAL_EXTERNAL_CA_CERT_DIR}/x509.ext.template" >"${LOCAL_EXTERNAL_CA_CERT_DIR}/x509.ext"
  else
    sed "s/HOST_NAME/${FQDN}/" "${LOCAL_CA_CERT_DIR}/x509.ext.template" >"${LOCAL_CA_CERT_DIR}/x509.ext"
  fi

  # Generate key
  run_java openssl genrsa -out "${KEY}" "${CERTIFICATE_KEY_SIZE}"
  # Generate certificate signing request
  run_java openssl req -new -key "${KEY}" -subj "/CN=${FQDN}" -out "${TMP}"
  # Generate certificate
  run_java openssl x509 -req -sha256 -CA "${CA_CER}" -CAkey "${CA_KEY}" -days "${CERTIFICATE_DURATION}" -CAcreateserial -CAserial "${CA_SRL}" -extfile "${EXT}" -extensions "${TYPE}" -in "${TMP}" -out "${CER}"

  # Clean up
  sudo chown -R "$(id -u):$(id -g)" "${GENERATED_SECRETS_DIR}"
  sudo chmod a+r "${GENERATED_SECRETS_DIR}/certificates/${HOST_NAME}/server.key" "${GENERATED_SECRETS_DIR}/certificates/${HOST_NAME}/server.cer"
  sudo rm "${GENERATED_SECRETS_DIR}/certificates/${HOST_NAME}-key.csr" "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}CA/x509.ext"
}

function create_ssl_certificates() {
  print "Creating SSL certificates"

  create_certificates "${ZK1_HOST_NAME}" "${ZK1_FQDN}" zk
  create_certificates "${ZK2_HOST_NAME}" "${ZK2_FQDN}" zk
  create_certificates "${ZK3_HOST_NAME}" "${ZK3_FQDN}" zk
  create_certificates "${SOLR1_HOST_NAME}" "${SOLR1_FQDN}" solr
  create_certificates "${SOLR2_HOST_NAME}" "${SOLR2_FQDN}" solr
  create_certificates "${SOLR3_HOST_NAME}" "${SOLR3_FQDN}" solr
  create_certificates "${SOLR_CLIENT_HOST_NAME}" "${SOLR_CLIENT_FQDN}" solr
  create_certificates "${I2A_TOOL_HOST_NAME}" "${I2A_TOOL_FQDN}" solr
  create_certificates "${LIBERTY1_HOST_NAME}" "${LIBERTY1_FQDN}" liberty
  create_certificates "${LIBERTY2_HOST_NAME}" "${LIBERTY2_FQDN}" liberty
  # create_certificates "${DB2_SERVER_HOST_NAME}" "${DB2_SERVER_FQDN}" db2
  create_certificates "${SQL_SERVER_HOST_NAME}" "${SQL_SERVER_FQDN}" sqlserver
  create_certificates "${POSTGRES_SERVER_HOST_NAME}" "${POSTGRES_SERVER_FQDN}" postgres
  create_certificates "${CONNECTOR1_HOST_NAME}" "${CONNECTOR1_FQDN}" connector
  create_certificates "${CONNECTOR2_HOST_NAME}" "${CONNECTOR2_FQDN}" connector
  create_certificates "${GATEWAY_CERT_FOLDER_NAME}" "${I2_GATEWAY_USERNAME}" liberty
  create_certificates "${I2_ANALYZE_CERT_FOLDER_NAME}" "${I2_ANALYZE_FQDN}" liberty external
  create_certificates "${PROMETHEUS_HOST_NAME}" "${PROMETHEUS_FQDN}" prometheus external
  create_certificates "${GRAFANA_HOST_NAME}" "${GRAFANA_FQDN}" grafana external
}

function generate_random_password() {
  local PASSWORD_FILE_LOCATION="$1"
  local password
  local max_retries=10

  if [[ -f "${PASSWORD_FILE_LOCATION}" ]]; then
    shred -u "${PASSWORD_FILE_LOCATION}"
  fi

  touch "${PASSWORD_FILE_LOCATION}"
  password="$(run_java openssl rand -base64 16)"
  while [[ -z "${password}" ]]; do
    if (("${max_retries}" == 0)); then
      print_error_and_exit "Unable to generate random password, exiting script"
    else
      print_warn "Having issues generating random password, retrying..."
      ((max_retries = "${max_retries}" - 1))
      password="$(run_java openssl rand -base64 16)"
    fi
  done

  printf "%s" "${password}" >"${PASSWORD_FILE_LOCATION}"
}

function generate_solr_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/solr"
  print "Generating Solr Passwords"

  check_secret_does_not_exist "Solr" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/SOLR_APPLICATION_DIGEST_PASSWORD"
  generate_random_password "${secrets_dir}/SOLR_ADMIN_DIGEST_PASSWORD"
  generate_random_password "${secrets_dir}/ZK_DIGEST_PASSWORD"
  generate_random_password "${secrets_dir}/ZK_DIGEST_READONLY_PASSWORD"
}

function generate_application_admin_password() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/application"

  print "Generating Application Passwords"
  check_secret_does_not_exist "Application" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/admin_PASSWORD"
}

function generate_sqlserver_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/sqlserver"

  print "Generating SQL Server Passwords"
  check_secret_does_not_exist "SQL Server" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/dbb_PASSWORD"
  generate_random_password "${secrets_dir}/i2analyze_PASSWORD"
  generate_random_password "${secrets_dir}/i2etl_PASSWORD"
  generate_random_password "${secrets_dir}/etl_PASSWORD"
  generate_random_password "${secrets_dir}/dba_PASSWORD"
  generate_random_password "${secrets_dir}/sa_PASSWORD"
  generate_random_password "${secrets_dir}/sa_INITIAL_PASSWORD"
}

function generate_postgres_server_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/postgres"

  print "Generating Postgres Server Passwords"
  check_secret_does_not_exist "Postgres Server" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/dbb_PASSWORD"
  generate_random_password "${secrets_dir}/i2analyze_PASSWORD"
  generate_random_password "${secrets_dir}/i2etl_PASSWORD"
  generate_random_password "${secrets_dir}/etl_PASSWORD"
  generate_random_password "${secrets_dir}/dba_PASSWORD"
  generate_random_password "${secrets_dir}/postgres_PASSWORD"
  generate_random_password "${secrets_dir}/postgres_INITIAL_PASSWORD"
}

function generate_db2server_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/db2server"

  print "Generating Db2 Server Passwords"
  check_secret_does_not_exist "Db2" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/db2inst1_PASSWORD"
  generate_random_password "${secrets_dir}/db2inst1_INITIAL_PASSWORD"
}

function generate_prometheus_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/prometheus"

  print "Generating Prometheus Passwords"
  check_secret_does_not_exist "Prometheus" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/admin_PASSWORD"
}

function generate_grafana_passwords() {
  local secrets_dir="${GENERATED_SECRETS_DIR}/grafana"

  print "Generating Grafana Passwords"
  check_secret_does_not_exist "Grafana" "${secrets_dir}" || return 0
  delete_folder_if_exists_and_create "${secrets_dir}"

  generate_random_password "${secrets_dir}/admin_PASSWORD"
}

function generate_solr_security_json() {
  local SOLR_ADMIN_SALT
  local SOLR_ADMIN_DIGEST
  local SOLR_APPLICATION_SALT
  local SOLR_APPLICATION_DIGEST

  print "Generating Solr security.json file"

  # Generate a random salt
  SOLR_ADMIN_SALT=$(openssl rand -base64 32)

  # Create the solr digest
  SOLR_ADMIN_DIGEST=$( (
    echo -n "${SOLR_ADMIN_SALT}" | base64 -d
    echo -n "$(cat "${GENERATED_SECRETS_DIR}/solr/SOLR_ADMIN_DIGEST_PASSWORD")"
  ) | openssl dgst -sha256 -binary | openssl dgst -sha256 -binary | base64)

  # Generate a random salt
  SOLR_APPLICATION_SALT=$(openssl rand -base64 32)

  # Create the solr digest
  SOLR_APPLICATION_DIGEST=$( (
    echo -n "${SOLR_APPLICATION_SALT}" | base64 -d
    echo -n "$(cat "${GENERATED_SECRETS_DIR}/solr/SOLR_APPLICATION_DIGEST_PASSWORD")"
  ) | openssl dgst -sha256 -binary | openssl dgst -sha256 -binary | base64)

  # Create the security.json file
  cat <"${ANALYZE_CONTAINERS_ROOT_DIR}/utils/templates/security-template.json" | jq '.authentication.credentials +=
  {
    "liberty":"'"${SOLR_APPLICATION_DIGEST} ${SOLR_APPLICATION_SALT}"'",
    "solr": "'"${SOLR_ADMIN_DIGEST} ${SOLR_ADMIN_SALT}"'"
  }' >"${GENERATED_SECRETS_DIR}/solr/security.json"
}

function simulate_container_secret_store_access() {
  local CONTEXT="$1"
  local TYPE="$2"

  print "Simulating Secret Store Access: ${CONTEXT}"

  delete_folder_if_exists_and_create "${LOCAL_KEYS_DIR}/${CONTEXT}"
  cp -pr "${GENERATED_SECRETS_DIR}/certificates/${CONTEXT}/." "${LOCAL_KEYS_DIR}/${CONTEXT}/"
  cp "${GENERATED_SECRETS_DIR}/certificates/${TYPE}CA/CA.cer" "${LOCAL_KEYS_DIR}/${CONTEXT}/CA.cer"
}

function simulate_liberty_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"
  cp "${GENERATED_SECRETS_DIR}/sqlserver/i2analyze_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/DB_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/SOLR_APPLICATION_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/SOLR_APPLICATION_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/ZK_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/gateway_user.cer"
  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.key" "${LOCAL_KEYS_DIR}/${HOST_NAME}/gateway_user.key"
  cp "${GENERATED_SECRETS_DIR}/certificates/CA/CA.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/outbound_CA.cer"
}

function simulate_solr_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"

  cp "${GENERATED_SECRETS_DIR}/solr/SOLR_ADMIN_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/SOLR_ADMIN_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/ZK_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_READONLY_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/ZK_DIGEST_READONLY_PASSWORD"
}

function simulate_zk_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/ZK_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_READONLY_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/ZK_DIGEST_READONLY_PASSWORD"
}

function simulate_sqlserver_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"
  cp "${GENERATED_SECRETS_DIR}/sqlserver/sa_INITIAL_PASSWORD" "${LOCAL_KEYS_DIR}/sqlserver/SA_PASSWORD"
}

function simulate_postgres_server_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"
  cp "${GENERATED_SECRETS_DIR}/postgres/postgres_INITIAL_PASSWORD" "${LOCAL_KEYS_DIR}/postgres/postgres_PASSWORD"
}

function simulate_db2server_secret_store_access() {
  local HOST_NAME="$1"

  simulate_container_secret_store_access "${HOST_NAME}"
  cp "${GENERATED_SECRETS_DIR}/db2server/db2inst1_INITIAL_PASSWORD" "${LOCAL_KEYS_DIR}/db2server/DB2INST1_PASSWORD"
}

function simulate_i2analyze_secret_store_access() {
  local HOST_NAME="$1"
  simulate_container_secret_store_access "${HOST_NAME}" external

  # Can be implemented as a load balancer or directly by Liberty. Add Liberty secrets
  cp "${GENERATED_SECRETS_DIR}/sqlserver/i2analyze_PASSWORD" "${LOCAL_KEYS_DIR}/${I2_ANALYZE_CERT_FOLDER_NAME}/DB_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/SOLR_APPLICATION_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${I2_ANALYZE_CERT_FOLDER_NAME}/SOLR_APPLICATION_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/solr/ZK_DIGEST_PASSWORD" "${LOCAL_KEYS_DIR}/${I2_ANALYZE_CERT_FOLDER_NAME}/ZK_DIGEST_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/gateway_user.cer"
  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.key" "${LOCAL_KEYS_DIR}/${HOST_NAME}/gateway_user.key"
  cp "${GENERATED_SECRETS_DIR}/certificates/CA/CA.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/outbound_CA.cer"
}

function simulate_prometheus_secret_store_access() {
  local HOST_NAME="$1"
  simulate_container_secret_store_access "${HOST_NAME}" external

  cp "${GENERATED_SECRETS_DIR}/prometheus/admin_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/PROMETHEUS_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/application/admin_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/LIBERTY_ADMIN_PASSWORD"

  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/out_server.cer"
  cp "${GENERATED_SECRETS_DIR}/certificates/gateway_user/server.key" "${LOCAL_KEYS_DIR}/${HOST_NAME}/out_server.key"
  cp "${GENERATED_SECRETS_DIR}/certificates/CA/CA.cer" "${LOCAL_KEYS_DIR}/${HOST_NAME}/outbound_CA.cer"
}

function simulate_grafana_secret_store_access() {
  local HOST_NAME="$1"
  simulate_container_secret_store_access "${HOST_NAME}" external

  cp "${GENERATED_SECRETS_DIR}/prometheus/admin_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/PROMETHEUS_PASSWORD"
  cp "${GENERATED_SECRETS_DIR}/grafana/admin_PASSWORD" "${LOCAL_KEYS_DIR}/${HOST_NAME}/GRAFANA_PASSWORD"
}

function simulate_server_secret_store_access() {
  create_folder "${LOCAL_KEYS_DIR}"
  simulate_liberty_secret_store_access "${LIBERTY1_HOST_NAME}"
  simulate_liberty_secret_store_access "${LIBERTY2_HOST_NAME}"
  simulate_zk_secret_store_access "${ZK1_HOST_NAME}"
  simulate_zk_secret_store_access "${ZK2_HOST_NAME}"
  simulate_zk_secret_store_access "${ZK3_HOST_NAME}"
  simulate_container_secret_store_access "${CONNECTOR1_HOST_NAME}"
  simulate_container_secret_store_access "${CONNECTOR2_HOST_NAME}"
  simulate_solr_secret_store_access "${SOLR1_HOST_NAME}"
  simulate_solr_secret_store_access "${SOLR2_HOST_NAME}"
  simulate_solr_secret_store_access "${SOLR3_HOST_NAME}"
  simulate_sqlserver_secret_store_access "${SQL_SERVER_HOST_NAME}"
  simulate_postgres_server_secret_store_access "${POSTGRES_SERVER_HOST_NAME}"
  # simulate_db2server_secret_store_access "${DB2_SERVER_HOST_NAME}"
  simulate_i2analyze_secret_store_access "${I2ANALYZE_HOST_NAME}"
  simulate_prometheus_secret_store_access "${PROMETHEUS_HOST_NAME}"
  simulate_grafana_secret_store_access "${GRAFANA_HOST_NAME}"
}

function generate_connector_secrets() {
  local connector_name connector_image_dir

  for connector_name in "${CONNECTORS_ARRAY[@]}"; do
    connector_image_dir="${CONNECTOR_IMAGES_DIR}/${connector_name}"
    [[ ! -d "${connector_image_dir}" ]] && continue
    generate_connector_secret "${connector_image_dir}"
  done
}

function generate_connector_secret() {
  local connector_image_dir="${1}"
  local connector_image_name
  local connector_secrets_folder
  local connector_type
  local hostname
  local connector_tag base_url

  connector_image_name="$(basename "${connector_image_dir}")"
  connector_secrets_folder="${GENERATED_SECRETS_DIR}/certificates/${connector_image_name}"

  if check_secret_does_not_exist "${connector_image_name}" "${connector_secrets_folder}"; then
    print "Generating secrets for ${connector_image_name}"
    connector_type=$(jq -r '.type' <"${connector_image_dir}/connector-definition.json")

    if [[ "${connector_type}" == "external" ]]; then
      base_url=$(jq -r '.baseUrl' <"${connector_image_dir}/connector-definition.json")
      hostname=$(echo "${base_url}" | awk -F[/:] '{print $4}')
    else
      connector_tag=$(jq -r '.tag' <"${connector_image_dir}/connector-version.json")
      hostname="${connector_image_name}-${connector_tag}.${DOMAIN_NAME}"
    fi
    create_certificates "${connector_image_name}" "${hostname}" "connector"
    simulate_container_secret_store_access "${connector_image_name}"
  fi
  update_volume "${LOCAL_KEYS_DIR}/${connector_image_name}" "${connector_image_name}_secrets" "${CONTAINER_SECRETS_DIR}"
}

function generate_core_secrets() {
  print "Generating secrets for core components"

  create_ca "CA"
  create_ca "externalCA"
  create_ssl_certificates
  generate_application_admin_password
  generate_solr_passwords
  generate_sqlserver_passwords
  generate_postgres_server_passwords
  # generate_db2server_passwords
  generate_prometheus_passwords
  generate_grafana_passwords
  generate_solr_security_json
  simulate_server_secret_store_access
  update_core_secrets_volumes
}

function main() {
  set_dependencies_tag_if_necessary
  if [[ "${TASK}" == "generate" ]]; then
    build_asset_array "connector" "connector-images"
    validate_connectors_exist

    if [[ "${COMPONENTS}" == "all" ]]; then
      generate_core_secrets
      generate_connector_secrets
    elif [[ "${COMPONENTS}" == "connectors" ]]; then
      generate_connector_secrets
    elif [[ "${COMPONENTS}" == "core" ]]; then
      generate_core_secrets
    fi
  elif [[ "${TASK}" == "clean" ]]; then
    print "Deleting existing secrets"
    delete_folder_if_exists_and_create "${DEV_ENV_SECRETS_DIR}"
    echo "${DEV_ENV_SECRETS_DIR} folder is clean"
  fi
}

main "$@"
